# Nginx configuration for CUFindIt
# Reverse proxy and SSL Endpoint
# Author: Jack Tabb
# Date Created: 01/25/2020
# Date Last Modified: 01/26/2020

events {

}

# Listen for HTTP requests
http {
    client_max_body_size 50m;

    # Forward all requests using HTTP to use HTTPS
    server {
        # Default server means this will be the first server block visited.
        #   This ensures we switch to encrypted communication ASAP
        listen 80 default_server;
        listen [::]:80 default_server; # Listen for IPv6, too.
        # Listen to any URL sent to the server that's running NGINX
        server_name _;
        # Redirect the request to use HTTPS, but with the same URL
        return 301 https://$host$request_uri;
    }

    # Handle requests for the main domain
    server {
        # Listen on Port 443 for ssl-encrypted HTTP (also known as HTTPS).
        #   Use HTTP/2 spec (newer, faster, more secure than HTTP/1.1)
        listen 443 ssl http2;
        listen [::]:443 ssl http2; # Listen for IPv6, too

        # Listen for HTTP requests to this URL with any subdomain
        server_name cufindit.tech;
        location / { # Default go to node server that is Docker port-mapped to 8081
            # AWS EC2 Private IP. Using the port mapped to the React and Node.js Docker container
            proxy_pass http://172.31.34.43:8081/;

            # Necessary HTTP headers for Wordpress to work with nginx reverse proxy
            #    Note: proxy_set_header sends HTTP headers to the backend server that we are proxying to.
            #          add_header sends HTTP headers to the client (browser).
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Host $http_host;
        }

        # location /portainer/ {
        #     # AWS EC2 Private IP. Using the port mapped to the Portainer Docker container
        #     proxy_pass http://172.31.34.43:9000/;

        #     # Necessary HTTP headers for Wordpress to work with nginx reverse proxy
        #     #    Note: proxy_set_header sends HTTP headers to the backend server that we are proxying to.
        #     #          add_header sends HTTP headers to the client (browser).
        #     proxy_set_header X-Forwarded-Proto $scheme;
        #     proxy_set_header Host $http_host;
        # }

        # Encryption Stuff
        # TODO: Possibly put all of this encryption stuff into a file that can be included as a configuration snippet at the bottom of each server block.
        # TODO: Try to implement Payment Card Industry (PCI) Data Security Standard (DSS) and get A+ rating on SSL Labs test.
           
            # Use the Lets Encrypt certificates generated by Certbot
            ssl_certificate     /etc/letsencrypt/live/cufindit.tech/fullchain.pem;
            ssl_certificate_key /etc/letsencrypt/live/cufindit.tech/privkey.pem;

            # SSL Session Settings
            ssl_session_timeout 60m; # 60 minutes
            ssl_session_cache   shared:SSL:10m;  # cache large enough for about 40000 sessions
            ssl_session_tickets off;
            
            # Diffie-Hellman Key Exchange Parameters
            # ssl_dhparam /etc/nginx/dhparam4096.pem;
            # The default 2048 key should be good enough.
            # If we need more security, we can use this file. But, it slows down the handshake.
            # I think Cerbot's default is also 2048. So, we'd need to regenerate those certificates, too.

            # SSL Protocols and Ciphers
            ssl_protocols TLSv1.3 TLSv1.2; # Need to upgrade OpenSSL to 1.1.1 and recompile nginx to support TLSv1.3
            ssl_prefer_server_ciphers on;
            ssl_ciphers "ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-SHA384";
            ssl_ecdh_curve secp384r1;

            # # SSL Online Certificate Status Protocol (OCSP) Stapling
            # #   Reduce Browser-Server connection initialization time by using DNS 
            # #       to periodically check certificate for revocation.
            # ssl_stapling            on;
            # ssl_stapling_verify     on;
            # ssl_trusted_certificate /etc/letsencrypt/live/ramboll.us/chain.pem;
            # resolver                8.8.8.8 8.8.4.4 valid=300s;
            # resolver_timeout        5s; 

            # # Security-focused HTTP Headers
            #     # HTTP Strict Transport Security (HSTS) -- Force client to use HTTPS by default and block HTTP
            #     add_header Strict-Transport-Security "max-age=63072000; includeSubDomains" always; # Long-term HSTS (One Year)
            #     # add_header Strict-Transport-Security "max-age=1209600; includeSubDomains" always; # Short-term HSTS (Two Weeks)
            #     # If this breaks and we can't access stuff anymore, then reset the client by first changing the max age here: max-age=0 and then refreshing the client (browser)
            #     # If ultimate security is needed, then put our web domain here: https://hstspreload.appspot.com/ 
            #     #   Then, add "preload" after the "includeSubDomains" option.
            #     #   This is Permanent HSTS (Submitted to all Browsers and hardcoded forever)
            #     #   I'm not doing that, though because we aren't doing anything super confidential

            #     # Reduce clickjacking attacks. By preventing pages from being displayed on <frame>, <iframe>, ...
            #     # We need to use iframe for Grafana, so don't use this header
            #     # add_header X-Frame-Options deny;

            #     # Prevent some cross-site-scripting (XSS) attacks
            #     # add_header X-XSS-Protection "1; mode=block;";
            #     # TODO: The above is deprecated. Use Content Security Policy (CSP) instead

            #     # Prevent MIME sniffing to reduce XSS attacks
            #     add_header X-Content-Type-Options nosniff;

            #     # Report on this server's Certificate Transparency
            #     add_header Expect-CT "max-age=0";
            #     # To enforce it, see example from Mozilla 
            #     #   Expect-CT: max-age=86400, enforce, report-uri="https://foo.example/report"
            #     #       https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expect-CT
    }

    # Handle requests for the test subdomain
    server {
        # Listen on Port 443 for ssl-encrypted HTTP (also known as HTTPS).
        #   Use HTTP/2 spec (newer, faster, more secure than HTTP/1.1)
        listen 443 ssl http2;
        listen [::]:443 ssl http2; # Listen for IPv6, too

        # Listen for HTTP requests to this URL with any subdomain
        server_name test.cufindit.tech;
        location / { # Default go to node server that is Docker port-mapped to 8080
            # AWS EC2 Private IP. Using the port mapped to the React and Node.js Docker container
            proxy_pass http://172.31.34.43:8080/;

            # Necessary HTTP headers for Wordpress to work with nginx reverse proxy
            #    Note: proxy_set_header sends HTTP headers to the backend server that we are proxying to.
            #          add_header sends HTTP headers to the client (browser).
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Host $http_host;
        }

        # location /portainer/ {
        #     # AWS EC2 Private IP. Using the port mapped to the Portainer Docker container
        #     proxy_pass http://172.31.34.43:9000/;

        #     # Necessary HTTP headers for Wordpress to work with nginx reverse proxy
        #     #    Note: proxy_set_header sends HTTP headers to the backend server that we are proxying to.
        #     #          add_header sends HTTP headers to the client (browser).
        #     proxy_set_header X-Forwarded-Proto $scheme;
        #     proxy_set_header Host $http_host;
        # }

        # Encryption Stuff
        # TODO: Possibly put all of this encryption stuff into a file that can be included as a configuration snippet at the bottom of each server block.
        # TODO: Try to implement Payment Card Industry (PCI) Data Security Standard (DSS) and get A+ rating on SSL Labs test.
           
            # Use the Lets Encrypt certificates generated by Certbot
            ssl_certificate     /etc/letsencrypt/live/cufindit.tech/fullchain.pem;
            ssl_certificate_key /etc/letsencrypt/live/cufindit.tech/privkey.pem;

            # SSL Session Settings
            ssl_session_timeout 60m; # 60 minutes
            ssl_session_cache   shared:SSL:10m;  # cache large enough for about 40000 sessions
            ssl_session_tickets off;
            
            # Diffie-Hellman Key Exchange Parameters
            # ssl_dhparam /etc/nginx/dhparam4096.pem;
            # The default 2048 key should be good enough.
            # If we need more security, we can use this file. But, it slows down the handshake.
            # I think Cerbot's default is also 2048. So, we'd need to regenerate those certificates, too.

            # SSL Protocols and Ciphers
            ssl_protocols TLSv1.3 TLSv1.2; # Need to upgrade OpenSSL to 1.1.1 and recompile nginx to support TLSv1.3
            ssl_prefer_server_ciphers on;
            ssl_ciphers "ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-SHA384";
            ssl_ecdh_curve secp384r1;

            # # SSL Online Certificate Status Protocol (OCSP) Stapling
            # #   Reduce Browser-Server connection initialization time by using DNS 
            # #       to periodically check certificate for revocation.
            # ssl_stapling            on;
            # ssl_stapling_verify     on;
            # ssl_trusted_certificate /etc/letsencrypt/live/ramboll.us/chain.pem;
            # resolver                8.8.8.8 8.8.4.4 valid=300s;
            # resolver_timeout        5s; 

            # # Security-focused HTTP Headers
            #     # HTTP Strict Transport Security (HSTS) -- Force client to use HTTPS by default and block HTTP
            #     add_header Strict-Transport-Security "max-age=63072000; includeSubDomains" always; # Long-term HSTS (One Year)
            #     # add_header Strict-Transport-Security "max-age=1209600; includeSubDomains" always; # Short-term HSTS (Two Weeks)
            #     # If this breaks and we can't access stuff anymore, then reset the client by first changing the max age here: max-age=0 and then refreshing the client (browser)
            #     # If ultimate security is needed, then put our web domain here: https://hstspreload.appspot.com/ 
            #     #   Then, add "preload" after the "includeSubDomains" option.
            #     #   This is Permanent HSTS (Submitted to all Browsers and hardcoded forever)
            #     #   I'm not doing that, though because we aren't doing anything super confidential

            #     # Reduce clickjacking attacks. By preventing pages from being displayed on <frame>, <iframe>, ...
            #     # We need to use iframe for Grafana, so don't use this header
            #     # add_header X-Frame-Options deny;

            #     # Prevent some cross-site-scripting (XSS) attacks
            #     # add_header X-XSS-Protection "1; mode=block;";
            #     # TODO: The above is deprecated. Use Content Security Policy (CSP) instead

            #     # Prevent MIME sniffing to reduce XSS attacks
            #     add_header X-Content-Type-Options nosniff;

            #     # Report on this server's Certificate Transparency
            #     add_header Expect-CT "max-age=0";
            #     # To enforce it, see example from Mozilla 
            #     #   Expect-CT: max-age=86400, enforce, report-uri="https://foo.example/report"
            #     #       https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expect-CT
    }

    # Handle requests for the Python image classification model
    server {
        # Listen on Port 443 for ssl-encrypted HTTP (also known as HTTPS).
        #   Use HTTP/2 spec (newer, faster, more secure than HTTP/1.1)
        listen 443 ssl http2;
        listen [::]:443 ssl http2; # Listen for IPv6, too

        # Listen for HTTP requests to this URL with any subdomain
        server_name api.cufindit.tech;
        location / { # Default go to node server that is Docker port-mapped to 8080
            # AWS EC2 Private IP. Using the port mapped to the Python Flask Docker container
            proxy_pass http://172.31.34.43:5000/;

            # Necessary HTTP headers for Wordpress to work with nginx reverse proxy
            #    Note: proxy_set_header sends HTTP headers to the backend server that we are proxying to.
            #          add_header sends HTTP headers to the client (browser).
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Host $http_host;

            # Get Flask Headers to work
            proxy_set_header Origin "";
            # proxy_set_header   X-Real-IP $remote_addr;
            # proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
            # proxy_set_header   X-Forwarded-Host $server_name;
            # # proxy_set_header   X-Forwarded-Proto: https;

        }

        # location /portainer/ {
        #     # AWS EC2 Private IP. Using the port mapped to the Portainer Docker container
        #     proxy_pass http://172.31.34.43:9000/;

        #     # Necessary HTTP headers for Wordpress to work with nginx reverse proxy
        #     #    Note: proxy_set_header sends HTTP headers to the backend server that we are proxying to.
        #     #          add_header sends HTTP headers to the client (browser).
        #     proxy_set_header X-Forwarded-Proto $scheme;
        #     proxy_set_header Host $http_host;
        # }

        # Encryption Stuff
        # TODO: Possibly put all of this encryption stuff into a file that can be included as a configuration snippet at the bottom of each server block.
        # TODO: Try to implement Payment Card Industry (PCI) Data Security Standard (DSS) and get A+ rating on SSL Labs test.
           
            # Use the Lets Encrypt certificates generated by Certbot
            ssl_certificate     /etc/letsencrypt/live/cufindit.tech/fullchain.pem;
            ssl_certificate_key /etc/letsencrypt/live/cufindit.tech/privkey.pem;

            # SSL Session Settings
            ssl_session_timeout 60m; # 60 minutes
            ssl_session_cache   shared:SSL:10m;  # cache large enough for about 40000 sessions
            ssl_session_tickets off;
            
            # Diffie-Hellman Key Exchange Parameters
            # ssl_dhparam /etc/nginx/dhparam4096.pem;
            # The default 2048 key should be good enough.
            # If we need more security, we can use this file. But, it slows down the handshake.
            # I think Cerbot's default is also 2048. So, we'd need to regenerate those certificates, too.

            # SSL Protocols and Ciphers
            ssl_protocols TLSv1.3 TLSv1.2; # Need to upgrade OpenSSL to 1.1.1 and recompile nginx to support TLSv1.3
            ssl_prefer_server_ciphers on;
            ssl_ciphers "ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-SHA384";
            ssl_ecdh_curve secp384r1;

            # # SSL Online Certificate Status Protocol (OCSP) Stapling
            # #   Reduce Browser-Server connection initialization time by using DNS 
            # #       to periodically check certificate for revocation.
            # ssl_stapling            on;
            # ssl_stapling_verify     on;
            # ssl_trusted_certificate /etc/letsencrypt/live/ramboll.us/chain.pem;
            # resolver                8.8.8.8 8.8.4.4 valid=300s;
            # resolver_timeout        5s; 

            # # Security-focused HTTP Headers
            #     # HTTP Strict Transport Security (HSTS) -- Force client to use HTTPS by default and block HTTP
            #     add_header Strict-Transport-Security "max-age=63072000; includeSubDomains" always; # Long-term HSTS (One Year)
            #     # add_header Strict-Transport-Security "max-age=1209600; includeSubDomains" always; # Short-term HSTS (Two Weeks)
            #     # If this breaks and we can't access stuff anymore, then reset the client by first changing the max age here: max-age=0 and then refreshing the client (browser)
            #     # If ultimate security is needed, then put our web domain here: https://hstspreload.appspot.com/ 
            #     #   Then, add "preload" after the "includeSubDomains" option.
            #     #   This is Permanent HSTS (Submitted to all Browsers and hardcoded forever)
            #     #   I'm not doing that, though because we aren't doing anything super confidential

            #     # Reduce clickjacking attacks. By preventing pages from being displayed on <frame>, <iframe>, ...
            #     # We need to use iframe for Grafana, so don't use this header
            #     # add_header X-Frame-Options deny;

            #     # Prevent some cross-site-scripting (XSS) attacks
            #     # add_header X-XSS-Protection "1; mode=block;";
            #     # TODO: The above is deprecated. Use Content Security Policy (CSP) instead

            #     # Prevent MIME sniffing to reduce XSS attacks
            #     add_header X-Content-Type-Options nosniff;

            #     # Report on this server's Certificate Transparency
            #     add_header Expect-CT "max-age=0";
            #     # To enforce it, see example from Mozilla 
            #     #   Expect-CT: max-age=86400, enforce, report-uri="https://foo.example/report"
            #     #       https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expect-CT
    }

    # Handle requests to Portainer
    server {
        # Listen on Port 443 for ssl-encrypted HTTP (also known as HTTPS).
        #   Use HTTP/2 spec (newer, faster, more secure than HTTP/1.1)
        listen 443 ssl http2;
        listen [::]:443 ssl http2; # Listen for IPv6, too

        # Listen for HTTP requests to this URL with any subdomain
        server_name portainer.cufindit.tech;
        location / { # Default go to node server that is Docker port-mapped to 8080
            # AWS EC2 Private IP. Using the port mapped to the Portainer container
            proxy_pass http://172.31.34.43:9000/;

            # Necessary HTTP headers for Wordpress to work with nginx reverse proxy
            #    Note: proxy_set_header sends HTTP headers to the backend server that we are proxying to.
            #          add_header sends HTTP headers to the client (browser).
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Host $http_host;

            # Get Flask Headers to work
            # proxy_set_header Origin "";
            # proxy_set_header   X-Real-IP $remote_addr;
            # proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
            # proxy_set_header   X-Forwarded-Host $server_name;
            # # proxy_set_header   X-Forwarded-Proto: https;

        }

        # location /portainer/ {
        #     # AWS EC2 Private IP. Using the port mapped to the Portainer Docker container
        #     proxy_pass http://172.31.34.43:9000/;

        #     # Necessary HTTP headers for Wordpress to work with nginx reverse proxy
        #     #    Note: proxy_set_header sends HTTP headers to the backend server that we are proxying to.
        #     #          add_header sends HTTP headers to the client (browser).
        #     proxy_set_header X-Forwarded-Proto $scheme;
        #     proxy_set_header Host $http_host;
        # }

        # Encryption Stuff
        # TODO: Possibly put all of this encryption stuff into a file that can be included as a configuration snippet at the bottom of each server block.
        # TODO: Try to implement Payment Card Industry (PCI) Data Security Standard (DSS) and get A+ rating on SSL Labs test.
           
            # Use the Lets Encrypt certificates generated by Certbot
            ssl_certificate     /etc/letsencrypt/live/cufindit.tech/fullchain.pem;
            ssl_certificate_key /etc/letsencrypt/live/cufindit.tech/privkey.pem;

            # SSL Session Settings
            ssl_session_timeout 60m; # 60 minutes
            ssl_session_cache   shared:SSL:10m;  # cache large enough for about 40000 sessions
            ssl_session_tickets off;
            
            # Diffie-Hellman Key Exchange Parameters
            # ssl_dhparam /etc/nginx/dhparam4096.pem;
            # The default 2048 key should be good enough.
            # If we need more security, we can use this file. But, it slows down the handshake.
            # I think Cerbot's default is also 2048. So, we'd need to regenerate those certificates, too.

            # SSL Protocols and Ciphers
            ssl_protocols TLSv1.3 TLSv1.2; # Need to upgrade OpenSSL to 1.1.1 and recompile nginx to support TLSv1.3
            ssl_prefer_server_ciphers on;
            ssl_ciphers "ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-SHA384";
            ssl_ecdh_curve secp384r1;

            # # SSL Online Certificate Status Protocol (OCSP) Stapling
            # #   Reduce Browser-Server connection initialization time by using DNS 
            # #       to periodically check certificate for revocation.
            # ssl_stapling            on;
            # ssl_stapling_verify     on;
            # ssl_trusted_certificate /etc/letsencrypt/live/ramboll.us/chain.pem;
            # resolver                8.8.8.8 8.8.4.4 valid=300s;
            # resolver_timeout        5s; 

            # # Security-focused HTTP Headers
            #     # HTTP Strict Transport Security (HSTS) -- Force client to use HTTPS by default and block HTTP
            #     add_header Strict-Transport-Security "max-age=63072000; includeSubDomains" always; # Long-term HSTS (One Year)
            #     # add_header Strict-Transport-Security "max-age=1209600; includeSubDomains" always; # Short-term HSTS (Two Weeks)
            #     # If this breaks and we can't access stuff anymore, then reset the client by first changing the max age here: max-age=0 and then refreshing the client (browser)
            #     # If ultimate security is needed, then put our web domain here: https://hstspreload.appspot.com/ 
            #     #   Then, add "preload" after the "includeSubDomains" option.
            #     #   This is Permanent HSTS (Submitted to all Browsers and hardcoded forever)
            #     #   I'm not doing that, though because we aren't doing anything super confidential

            #     # Reduce clickjacking attacks. By preventing pages from being displayed on <frame>, <iframe>, ...
            #     # We need to use iframe for Grafana, so don't use this header
            #     # add_header X-Frame-Options deny;

            #     # Prevent some cross-site-scripting (XSS) attacks
            #     # add_header X-XSS-Protection "1; mode=block;";
            #     # TODO: The above is deprecated. Use Content Security Policy (CSP) instead

            #     # Prevent MIME sniffing to reduce XSS attacks
            #     add_header X-Content-Type-Options nosniff;

            #     # Report on this server's Certificate Transparency
            #     add_header Expect-CT "max-age=0";
            #     # To enforce it, see example from Mozilla 
            #     #   Expect-CT: max-age=86400, enforce, report-uri="https://foo.example/report"
            #     #       https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expect-CT
    }
    #  # Handle requests for Customer 2's WordPress
    # server {
    #     # Listen on Port 443 for ssl-encrypted HTTP (also known as HTTPS).
    #     #   Use HTTP/2 spec (newer, faster, more secure than HTTP/1.1)
    #     listen 443 ssl http2;
    #     listen [::]:443 ssl http2; # Listen for IPv6, too

    #     # Listen for HTTP requests to this URL with any subdomain
    #     server_name customer2.ramboll.us;
    #     location / {
    #         # AWS EC2 Private IP. Using the port mapped to the WordPress Docker container
    #         proxy_pass http://172.31.44.0:8081/;

    #         # Necessary HTTP headers for Wordpress to work with nginx reverse proxy
    #         #    Note: proxy_set_header sends HTTP headers to the backend server that we are proxying to.
    #         #          add_header sends HTTP headers to the client (browser).
    #         proxy_set_header X-Forwarded-Proto $scheme;
    #         proxy_set_header Host $http_host;
    #     }

    # Handle requests for main app
#     server {
#         # Listen on Port 443 for ssl-encrypted HTTP (also known as HTTPS).
#         #   Use HTTP/2 spec (newer, faster, more secure than HTTP/1.1)
#         listen 443 ssl http2;
#         listen [::]:443 ssl http2; # Listen for IPv6, too

#         # Listen for HTTP requests to this URL
#         server_name cufindit.tech;
#         location /portainer/ {
#             # AWS EC2 Private IP. Using the port mapped to the Portainer Docker container
#             proxy_pass http://172.31.44.0:9000/;

#             # HTTP headers for Portainer to work with ngninx reverse proxy
#             proxy_set_header X-Forwarded-Proto $scheme;
#         }

#         # Encryption Stuff
#         # TODO: Possibly put all of this encryption stuff into a file that can be included as a configuration snippet at the bottom of each server block.
#         # TODO: Try to implement Payment Card Industry (PCI) Data Security Standard (DSS) and get A+ rating on SSL Labs test.
           
#             # Use the Lets Encrypt certificates generated by Certbot
#             ssl_certificate     /etc/letsencrypt/live/ramboll.us/fullchain.pem;
#             ssl_certificate_key /etc/letsencrypt/live/ramboll.us/privkey.pem;

#             # SSL Session Settings
#             ssl_session_timeout 60m; # 60 minutes
#             ssl_session_cache   shared:SSL:10m;  # cache large enough for about 40000 sessions
#             ssl_session_tickets off;
            
#             # Diffie-Hellman Key Exchange Parameters
#             # ssl_dhparam /etc/nginx/dhparam4096.pem;
#             # The default 2048 key should be good enough.
#             # If we need more security, we can use this file. But, it slows down the handshake.
#             # I think Cerbot's default is also 2048. So, we'd need to regenerate those certificates, too.

#             # SSL Protocols and Ciphers
#             ssl_protocols TLSv1.2; # Need to upgrade OpenSSL to 1.1.1 and recompile nginx to support TLSv1.3
#             ssl_prefer_server_ciphers on;
#             ssl_ciphers "ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES256-SHA384";
#             ssl_ecdh_curve secp384r1;

#             # SSL Online Certificate Status Protocol (OCSP) Stapling
#             #   Reduce Browser-Server connection initialization time by using DNS 
#             #       to periodically check certificate for revocation.
#             ssl_stapling            on;
#             ssl_stapling_verify     on;
#             ssl_trusted_certificate /etc/letsencrypt/live/ramboll.us/chain.pem;
#             resolver                8.8.8.8 8.8.4.4 valid=300s;
#             resolver_timeout        5s; 

#             # Security-focused HTTP Headers
#                 # HTTP Strict Transport Security (HSTS) -- Force client to use HTTPS by default and block HTTP
#                 add_header Strict-Transport-Security "max-age=63072000; includeSubDomains" always; # Long-term HSTS (One Year)
#                 # add_header Strict-Transport-Security "max-age=1209600; includeSubDomains" always; # Short-term HSTS (Two Weeks)
#                 # If this breaks and we can't access stuff anymore, then reset the client by first changing the max age here: max-age=0 and then refreshing the client (browser)
#                 # If ultimate security is needed, then put our web domain here: https://hstspreload.appspot.com/ 
#                 #   Then, add "preload" after the "includeSubDomains" option.
#                 #   This is Permanent HSTS (Submitted to all Browsers and hardcoded forever)
#                 #   I'm not doing that, though because we aren't doing anything super confidential

#                 # Reduce clickjacking attacks. By preventing pages from being displayed on <frame>, <iframe>, ...
#                 # We need to use iframe for Grafana, so don't use this header
#                 # add_header X-Frame-Options deny;

#                 # Prevent some cross-site-scripting (XSS) attacks
#                 # add_header X-XSS-Protection "1; mode=block;";
#                 # TODO: The above is deprecated. Use Content Security Policy (CSP) instead

#                 # Prevent MIME sniffing to reduce XSS attacks
#                 add_header X-Content-Type-Options nosniff;

#                 # Report on this server's Certificate Transparency
#                 add_header Expect-CT "max-age=0";
#                 # To enforce it, see example from Mozilla 
#                 #   Expect-CT: max-age=86400, enforce, report-uri="https://foo.example/report"
#                 #       https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expect-CT
#     }
}

